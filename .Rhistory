m1 <- matrix(c(4,7,3,8,9,2),nrow=2) #matrix with 6 values, 2 rows
m1
m1[,2]
numbers_1 <- rnorm(80,mean=0,sd=1)
numbers_1
mat_1 <- matrix(numbers_1,nrow=20,ncol=4)
mat_1
df_1 <- data.frame(mat_1)
df_1
names(df_1) <- c("var1","var2","var3","var4")
df_1 #now with var1, var2, var3 and var4
head(df_1)
summary(df_1)
test <- data.frame(A=c(1,2,3),B=c("aB1","aB2","aB3"))
test
test[,1]
test[,"A"]
test$A
test$B
df_1 <- data.frame(plot="location_name_1", measure1=runif(100)*1000, measure2=round(runif(100)*100),value=rnorm(100,2,1),ID=rep(LETTERS,100))
df_1
df_2
df_2 <- data.frame(plot="location_name_2",measure1=runif(50)*100, measure2=round(runif(50)*10),value=rnorm(50),ID=rep(LETTERS,50))
df_2
df <- rbind(df_1,df_2)
df
test <- data.frame(A=c(1,2,3),B=c("aB1","aB2","aB3"))
test
test[,1] # first col
test[,"A"] #first col, referred to as A
test$A #same
test$B #second col
df_1 <- data.frame(plot="location_name_1", measure1=runif(100)*1000, measure2=round(runif(100)*100),value=rnorm(100,2,1),ID=rep(LETTERS,100))
df_1
df_2 <- data.frame(plot="location_name_2",measure1=runif(50)*100, measure2=round(runif(50)*10),value=rnorm(50),ID=rep(LETTERS,50))
df_2
df <- rbind(df_1,df_2)
df
summary(df)
str(df)
mode(df)
head(df)
df[,c('plot','measure1','measure2')]
df
df[66:115,c('plot','measure1','measure2')]
df[1:1,c('plot','measure1','measure2')]
df[1:2,c('plot','measure1','measure2')]
df[-1,c('plot','measure1','measure2')]
df[1,c('plot','measure1','measure2')]
df[66:70,c('plot','measure1','measure2')]
df[,c('measure1','measure2')]
plot(df[,c('measure1','measure2')])
plot(df[,c('measure1'])
df[,c('measure1']
df[,c('measure1')]
plot(df[,c('measure1')])
boxplot(df[,c('measure1','measure2')])
hist(df[,c('measure1')]
hist(df[,c('measure1')])
hist(df[('measure1')])
hist(df[(,'measure1')])
plot(df[,('measure1')])
plot(df[,c('measure1')])
hist(df[,('measure1')])
coplot(df[,c('measure1','measure2')])
library(raster)
germany <- getData("GADM",country="DEU",level=2)
plot(germany)
prec <- getData("worldclim",var="prec",res=.5,lon=10, lat=51)
plot(prec)
prec <- getData("worldclim",var="prec",res=.5,lon=10, lat=51)
plot(prec)
prec_ger1 <- crop(prec, germany)
plot(prec_ger1) #das geht auch!
spplot(prec_ger1)
prec_ger2 <- mask(prec_ger1,germany, inverse=TRUE)
spplot(prec_ger2)
prec_ger2 <- mask(prec_ger1,germany) #inverse=T f端hrt zur Inversion
prec_ger2 <- mask(prec_ger1,germany,inverse=F) #inverse=T f端hrt zur Inversion
germany <- getData("GADM",country="DEU",level=2)
prec <- getData("worldclim",var="prec",res=.5,lon=10, lat=51)
prec_ger1 <- crop(prec, germany)
prec_ger2 <- mask(prec_ger1,germany) #inverse=T f端hrt zur Inversion
spplot(prec_ger2)
prec_ger2 <- mask(prec_ger1,germany) #inverse=T f端hrt zur Inversion
spplot(prec_ger2)
prec_avg <- cellStats(pre_ger2,stat="mean")
prec_avg <- cellStats(prec_ger2,stat="mean")
prec
prec
prec_avg
prec_avg[7]
plot(prec_avg[7])
plot(prec_avg[4:9])
prec_avg[2]-prec_avg[1]
sum(prec_avg)
cumsum(pre)
cumsum(prec_avg)
max(prec_avg)
range(prec_avg)
which.min(prec_avg)
prec_avg
which.min(prec_avg)
which.min(abs(prec_avg-50))
diff(prec)
diff(prec_avg)
df[df$value>3.0,]
df[df$value<1.0,]
df[df$value>3.0,]
df[df$value>3.2 | df$measure1>50,]
df[df$value>3.2 & df$measure1>50,]
df$new_col <- df$measure1*df$measure2
df$new_col
df[grep("a",df$ID, ignore.case = T),]
df[grep("a",df$ID, ignore.case = F),]
#p.45 bzw. 83
x1 <- rbinom(10,size=1,prob=0.5)
x1
x2 <- factor(x1,labels=c("man","woman"))
x2
summary(x2)
levels(x2)
as.character(x2)
x2
x2
library(car)
recode(x2,"'woman'='woman'; 'man'='guy'")
library(car)
recode(x2,"'woman'='woman'; 'man'='guy'")
x2
library(car)
x2
recode(x2,"'woman'='woman'; 'man'='guy'")
x2
ifelse(x2=="man","guy","woman")
dd <- ifelse(x2=="man","guy","woman")
dd
library(raster)
install.packages("raster")
install.packages("raster")
install.packages("sp")
install.packages("sp")
r1 <- raster(nrows=10, ncol=10)
r1
r1[] <- rnorm(100)
plot(r1)
library(sp)
poi1 <- cbind(c(rnorm(10)),c(rnorm(10)))
poi1
poi1.sp <- SpatialPoints(poi1)
plot(poi1.sp)
df <- data.frame(attr1=c("a","b","z","d","e","q","w","r","z","y"), atrr2=c(101:110)) #creating values
df
poi1.spdf <- SpatialPointsDataFrame(poi1.sp,df)
plot(poi1.spdf)
poi1 <- cbind(c(rnorm(10)),c(rnorm(10))) #create 10 random coordinate pairs
poi1 #look at the output
poi1.sp <- SpatialPoints(poi1) #convert list of c. to a spatial object
plot(poi1.sp) #plot the spatial point data set
df <- data.frame(attr1=c("a","b","z","d","e","q","w","r","z","y"), atrr2=c(101:110)) #creating values
plot(poi1.sp) #plot the spatial point data set
plot(poi1.sp) #plot the spatial point data set
df <- data.frame(attr1=c("a","b","z","d","e","q","w","r","z","y"), atrr2=c(101:110)) #creating values
df
poi1.spdf <- SpatialPointsDataFrame(poi1.sp,df)
plot(poi1.spdf)
plot(poi1.spdf)
plot(poi1.sp) #plot the spatial point data set
install.packages("RStoolbox")
lsat
library(RStoolbox)
lsat
lsat[[1]]
plot(lsat[[1]])
x <- lsat[[2:3]]
x
plot(x)
qq <- x[x$B2_dn >18]
plot(qq)
lsat[[1]]
plot(lsat[[2:3]]) #plot band 2 and 3
plot(lsat$B1_dn)#plot band 1 option 2
data(lsat)
x <- lsat[1:10,]
x <- lsat[lsat$B1_dn > 10] #based on logical query
x
poly <- readRDS(system.file("external/trainingPolygons.rds",package = "RStoolbox"))
env <- raster(poly, vals=rnorm(100))
env
plot(env)
x <- extract(env, poly)
x
lsat[] <- rnorm(ncell(lsat))
lsat[]
lsat [lsat < 0] <- NA #set all values below 0 to NA
lsat [lsat < 0] <- NA #set all values below 0 to NA
lsat[]
env[] <- 0
env[]
env[leroy] <- 1
env[poly <- 1
env[poly] <- 1
env[] <- 0 all values in env set to 0 and poly areas to one
env[] <- 0 #all values in env set to 0 and poly areas to one
env[]
env[poly] <- 1
env[]
env[ <- 1
env[] <- 1
env[]
env[] <- 0 #all values in env set to 0 and poly areas to one
env[] <- 1
env[]
env[poly] <- 1
env[]
CRAN_df <- read.table(file="C:/Silvan/Silvan/cm_bundle/CRAN051001a.txt", header = TRUE)
CRAN_mat <- cbind(CRAN_df$long, CRAN_df$lat)
row.names(CRAN_mat) <- 1:nrow(CRAN_mat)
str(CRAN_mat)
CRAN_df <- read.table(file.choose(), header = TRUE)
CRAN_mat <- cbind(CRAN_df$long, CRAN_df$lat)
row.names(CRAN_mat) <- 1:nrow(CRAN_mat)
str(CRAN_mat)
CRAN_mat
row.names((CRAN_mat))
str(CRAN_mat)
getClass("SpatialPoints") #get class definition of "SpatialPoints"
llCRS <- CRS("+proj=longlat +ellps=WGS84")
CRAN_sp <- SpatialPoints(CRAN_mat, proj4string = llCRS)
summary(CRAN_sp)
bbox(CRAN_sp)
CRAN_sp
plot(CRAN_sp)
bbox(CRAN_sp) #bounding box
proj4string(CRAN_sp)
proj4string(CRAN_sp) <- CRS(as.character(NA))
proj4string(CRAN_sp)
CRAN_df <- read.table(file.choose(), header = TRUE) #read data using file.choose()
CRAN_mat <- cbind(CRAN_df$long, CRAN_df$lat) #combining longitude and latitude in CRAN_mat
CRAN_mat #additional to check result
row.names(CRAN_mat) <- 1:nrow(CRAN_mat) #rownames
str(CRAN_mat)
getClass("SpatialPoints") #get class definition of "SpatialPoints"
llCRS <- CRS("+proj=longlat +ellps=WGS84")
CRAN_sp <- SpatialPoints(CRAN_mat, proj4string = llCRS)
summary(CRAN_sp)
bbox(CRAN_sp) #bounding box
proj4string(CRAN_sp)
proj4string(CRAN_sp) <- CRS(as.character(NA))
proj4string(CRAN_sp)
proj4string(CRAN_sp) <- llCRS
proj4string(CRAN_sp)
brazil <- which(CRAN_df$loc == "Brazil")
brazil
coordinates(CRAN_sp)[brazil, ]
summary(CRAN_sp[brazil, ])
south_of_equator <- which(coordinates(CRAN_sp)[, 2] <0)
summary(CRAN_sp[-south_of_equator, ])
str(row.names(CRAN_df))
CRAN_spdf1 <- SpatialPointsDataFrame(CRAN_mat, CRAN_df,proj4string = llCRS, match.ID = TRUE)
CRAN_spdf1[4, ]
str(CRAN_spdf1$loc)
str(CRAN_spdf1)
CRAN_spdf1
CRAN_spdf1[4, ]
str(CRAN_spdf1$loc)
str(CRAN_spdf1[["loc"]])
s <- sample(nrow(CRAN_df))
s
s
all.equal(CRAN_spdf2, CRAN_spdf1)
s <- sample(nrow(CRAN_df)) #random samples of CRAN_df assigned to s
CRAN_spdf2 <- SpatialPointsDataFrame(CRAN_mat, CRAN_df[s,], proj4string = llCRS, match.ID = TRUE)
all.equal(CRAN_spdf2, CRAN_spdf1)
CRAN_spdf2[4, ]
CRAN_df1 <- CRAN_df
row.names(CRAN_df1) <- sample(c(outer(letters, letters,paste, sep = "")), nrow(CRAN_df1))
CRAN_spdf3 <- SpatialPointsDataFrame(CRAN_mat, CRAN_df1,proj4string = llCRS, match.ID = TRUE)
CRAN_df1 <- CRAN_df
row.names(CRAN_df1) <- sample(c(outer(letters, letters,paste, sep = "")), nrow(CRAN_df1)) #outer() =outer product of arrays
CRAN_spdf3 <- SpatialPointsDataFrame(CRAN_mat, CRAN_df1,proj4string = llCRS, match.ID = TRUE)
getClass("SpatialPointsDataFrame")
names(CRAN_spdf1)
str(model.frame(lat ~ long, data = CRAN_spdf1), give.attr = FALSE)
CRAN_spdf4 <- SpatialPointsDataFrame(CRAN_sp, CRAN_df)
all.equal(CRAN_spdf4, CRAN_spdf2)
CRAN_df0 <- CRAN_df
coordinates(CRAN_df0) <- CRAN_mat
proj4string(CRAN_df0) <- llCRS
all.equal(CRAN_df0, CRAN_spdf2)
str(CRAN_df0, max.level = 2)
str(CRAN_df0, max.level = 2)
CRAN_df1 <- CRAN_df
names(CRAN_df1)
coordinates(CRAN_df1) <- c("long", "lat")
proj4string(CRAN_df1) <- llCRS
str(CRAN_df1, max.level = 2)
CRAN_df1 <- CRAN_df
CRAN_df1 #additinal
names(CRAN_df1)
proj4string(CRAN_df1) <- llCRS
coordinates(CRAN_df1) <- c("long", "lat")
proj4string(CRAN_df1) <- llCRS
str(CRAN_df1, max.level = 2)
turtle_df <- read.csv(file.choose())
turtle_df <- read.csv(file.choose())
summary(turtle_df)
timestamp <- as.POSIXlt(strptime(as.character(turtle_df$obs_date),"%m/%d/%Y %H:%M:%S"), "GMT")
turtle_df1 <- data.frame(turtle_df, timestamp = timestamp)
turtle_df1$lon <- ifelse(turtle_df1$lon < 0, turtle_df1$lon +
+ 360, turtle_df1$lon)
turtle_df1$lon <- ifelse(turtle_df1$lon < 0, turtle_df1$lon 360, turtle_df1$lon)
turtle_df1$lon <- ifelse(turtle_df1$lon < 0, turtle_df1$lon +360, turtle_df1$lon)
timestamp <- as.POSIXlt(strptime(as.character(turtle_df$obs_date),"%m/%d/%Y %H:%M:%S"), "GMT")
turtle_df1 <- data.frame(turtle_df, timestamp = timestamp)
turtle_sp <- turtle_df1[order(turtle_df1$timestamp), ]
coordinates(turtle_sp) <- c("lon", "lat")
proj4string(turtle_sp) <- CRS("+proj=longlat +ellps=WGS84")
getClass("Line")
getClass("Lines")
getClass("SpatialLines")
install.packages("maps")
library(maps)
install.packages("maptools")
library(maps)
library(maptools)
japan <- map("world", "japan", plot = FALSE)
japan <- map("world", "japan", plot = T
japan <- map("world", "japan", plot = T)
japan <- map("world", "japan", plot = T)
p4s <- CRS("+proj=longlat +ellps=WGS84")
japan <- map("world", "japan", plot = FALSE) #alternatively: set plot to T and get map of japan
SLjapan <- map2SpatialLines(japan, proj4string = p4s)
str(SLjapan, max.level = 2)
Lines_len <- sapply(slot(SLjapan, "lines"), function(x) length(slot(x,"Lines")))
Lines_len <- sapply(slot(SLjapan, "lines"), function(x) length(slot(x,"Lines")))
table(Lines_len)
Lines_len <- lapply(slot(SLjapan, "lines"), function(x) length(slot(x,"Lines")))
table(Lines_len)
Lines_len <- lapply(slot(SLjapan, "lines"), function(x) length(slot(x,"Lines")))
table(Lines_len)
Lines_len <- sapply(slot(SLjapan, "lines"), function(x) length(slot(x,"Lines")))
table(Lines_len)
Lines_len <- lapply(slot(SLjapan, "lines"), function(x) length(slot(x,"Lines")))
table(Lines_len)
volcano_sl <- ContourLines2SLDF(contourLines(volcano))
t(slot(volcano_sl, "data"))
auck_shore <- MapGen2SL(file.choose(), llCRS)
llCRS <- CRS("+proj=longlat +ellps=WGS84")
auck_shore <- MapGen2SL(file.choose(), llCRS)
summary(auck_shore)
lns <- slot(auck_shore, "lines")
table(sapply(lns, function(x) length(slot(x, "Lines"))))
islands_auck <- sapply(lns, function(x) {
+ crds <- slot(slot(x, "Lines")[[1]], "coords")
+ identical(crds[1, ], crds[nrow(crds), ])
+ })
islands_auck <- sapply(lns, function(x) {
+ crds <- slot(slot(x, "Lines")[[1]], "coords")
+ identical(crds[1, ], crds[nrow(crds), ]) })
islands_auck <- sapply(lns, function(x) {
crds <- slot(slot(x, "Lines")[[1]], "coords")
identical(crds[1, ], crds[nrow(crds), ]) })
islands_auck <- sapply(lns, function(x) {
crds <- slot(slot(x, "Lines")[[1]], "coords")
identical(crds[1, ], crds[nrow(crds), ]) })
table(islands_auck)
#p.42
plot(islands_auck)
getClass("Polygon")
getClass("Polygons")
getClass("SpatialPolygons")
#p.44
islands_sl <- auck_shore[islands_auck]
list_of_Lines <- slot(islands_sl, "lines")
islands_sp <- SpatialPolygons(lapply(list_of_Lines, function(x) {
Polygons(list(Polygon(slot(slot(x, "Lines")[[1]],
"coords"))), ID = slot(x, "ID"))
}), proj4string = CRS("+proj=longlat +ellps=WGS84"))
summary(islands_sp)
order(sapply(slot(islands_sp, "polygons"), function(x) slot(x,"area")), decreasing = TRUE)
